// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: emitvalues/sawzall.proto

#ifndef PROTOBUF_emitvalues_2fsawzall_2eproto__INCLUDED
#define PROTOBUF_emitvalues_2fsawzall_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace sawzall {
class SzlFieldProto;
class SzlFieldProtoDefaultTypeInternal;
extern SzlFieldProtoDefaultTypeInternal _SzlFieldProto_default_instance_;
class SzlTypeProto;
class SzlTypeProtoDefaultTypeInternal;
extern SzlTypeProtoDefaultTypeInternal _SzlTypeProto_default_instance_;
}  // namespace sawzall

namespace sawzall {

namespace protobuf_emitvalues_2fsawzall_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_emitvalues_2fsawzall_2eproto

enum SzlTypeProto_KIND {
  SzlTypeProto_KIND_VOID = 0,
  SzlTypeProto_KIND_BOOL = 1,
  SzlTypeProto_KIND_BYTES = 2,
  SzlTypeProto_KIND_FINGERPRINT = 3,
  SzlTypeProto_KIND_FLOAT = 4,
  SzlTypeProto_KIND_INT = 5,
  SzlTypeProto_KIND_STRING = 6,
  SzlTypeProto_KIND_TIME = 7,
  SzlTypeProto_KIND_TUPLE = 8,
  SzlTypeProto_KIND_ARRAY = 9,
  SzlTypeProto_KIND_MAP = 10,
  SzlTypeProto_KIND_TABLE = 11,
  SzlTypeProto_KIND_FUNCTION = 12,
  SzlTypeProto_KIND_NKIND = 13
};
bool SzlTypeProto_KIND_IsValid(int value);
const SzlTypeProto_KIND SzlTypeProto_KIND_KIND_MIN = SzlTypeProto_KIND_VOID;
const SzlTypeProto_KIND SzlTypeProto_KIND_KIND_MAX = SzlTypeProto_KIND_NKIND;
const int SzlTypeProto_KIND_KIND_ARRAYSIZE = SzlTypeProto_KIND_KIND_MAX + 1;

const ::google::protobuf::EnumDescriptor* SzlTypeProto_KIND_descriptor();
inline const ::std::string& SzlTypeProto_KIND_Name(SzlTypeProto_KIND value) {
  return ::google::protobuf::internal::NameOfEnum(
    SzlTypeProto_KIND_descriptor(), value);
}
inline bool SzlTypeProto_KIND_Parse(
    const ::std::string& name, SzlTypeProto_KIND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SzlTypeProto_KIND>(
    SzlTypeProto_KIND_descriptor(), name, value);
}
// ===================================================================

class SzlFieldProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sawzall.SzlFieldProto) */ {
 public:
  SzlFieldProto();
  virtual ~SzlFieldProto();

  SzlFieldProto(const SzlFieldProto& from);

  inline SzlFieldProto& operator=(const SzlFieldProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SzlFieldProto(SzlFieldProto&& from) noexcept
    : SzlFieldProto() {
    *this = ::std::move(from);
  }

  inline SzlFieldProto& operator=(SzlFieldProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SzlFieldProto& default_instance();

  static inline const SzlFieldProto* internal_default_instance() {
    return reinterpret_cast<const SzlFieldProto*>(
               &_SzlFieldProto_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(SzlFieldProto* other);
  friend void swap(SzlFieldProto& a, SzlFieldProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SzlFieldProto* New() const PROTOBUF_FINAL { return New(NULL); }

  SzlFieldProto* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SzlFieldProto& from);
  void MergeFrom(const SzlFieldProto& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SzlFieldProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Label = 1;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 1;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // required string Type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional int32 Tag = 3;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 3;
  ::google::protobuf::int32 tag() const;
  void set_tag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sawzall.SzlFieldProto)
 private:
  void set_has_label();
  void clear_has_label();
  void set_has_type();
  void clear_has_type();
  void set_has_tag();
  void clear_has_tag();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::int32 tag_;
  friend struct protobuf_emitvalues_2fsawzall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SzlTypeProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sawzall.SzlTypeProto) */ {
 public:
  SzlTypeProto();
  virtual ~SzlTypeProto();

  SzlTypeProto(const SzlTypeProto& from);

  inline SzlTypeProto& operator=(const SzlTypeProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SzlTypeProto(SzlTypeProto&& from) noexcept
    : SzlTypeProto() {
    *this = ::std::move(from);
  }

  inline SzlTypeProto& operator=(SzlTypeProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SzlTypeProto& default_instance();

  static inline const SzlTypeProto* internal_default_instance() {
    return reinterpret_cast<const SzlTypeProto*>(
               &_SzlTypeProto_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SzlTypeProto* other);
  friend void swap(SzlTypeProto& a, SzlTypeProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SzlTypeProto* New() const PROTOBUF_FINAL { return New(NULL); }

  SzlTypeProto* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SzlTypeProto& from);
  void MergeFrom(const SzlTypeProto& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SzlTypeProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SzlTypeProto_KIND KIND;
  static const KIND VOID =
    SzlTypeProto_KIND_VOID;
  static const KIND BOOL =
    SzlTypeProto_KIND_BOOL;
  static const KIND BYTES =
    SzlTypeProto_KIND_BYTES;
  static const KIND FINGERPRINT =
    SzlTypeProto_KIND_FINGERPRINT;
  static const KIND FLOAT =
    SzlTypeProto_KIND_FLOAT;
  static const KIND INT =
    SzlTypeProto_KIND_INT;
  static const KIND STRING =
    SzlTypeProto_KIND_STRING;
  static const KIND TIME =
    SzlTypeProto_KIND_TIME;
  static const KIND TUPLE =
    SzlTypeProto_KIND_TUPLE;
  static const KIND ARRAY =
    SzlTypeProto_KIND_ARRAY;
  static const KIND MAP =
    SzlTypeProto_KIND_MAP;
  static const KIND TABLE =
    SzlTypeProto_KIND_TABLE;
  static const KIND FUNCTION =
    SzlTypeProto_KIND_FUNCTION;
  static const KIND NKIND =
    SzlTypeProto_KIND_NKIND;
  static inline bool KIND_IsValid(int value) {
    return SzlTypeProto_KIND_IsValid(value);
  }
  static const KIND KIND_MIN =
    SzlTypeProto_KIND_KIND_MIN;
  static const KIND KIND_MAX =
    SzlTypeProto_KIND_KIND_MAX;
  static const int KIND_ARRAYSIZE =
    SzlTypeProto_KIND_KIND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  KIND_descriptor() {
    return SzlTypeProto_KIND_descriptor();
  }
  static inline const ::std::string& KIND_Name(KIND value) {
    return SzlTypeProto_KIND_Name(value);
  }
  static inline bool KIND_Parse(const ::std::string& name,
      KIND* value) {
    return SzlTypeProto_KIND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .sawzall.SzlFieldProto Indices = 4;
  int indices_size() const;
  void clear_indices();
  static const int kIndicesFieldNumber = 4;
  const ::sawzall::SzlFieldProto& indices(int index) const;
  ::sawzall::SzlFieldProto* mutable_indices(int index);
  ::sawzall::SzlFieldProto* add_indices();
  ::google::protobuf::RepeatedPtrField< ::sawzall::SzlFieldProto >*
      mutable_indices();
  const ::google::protobuf::RepeatedPtrField< ::sawzall::SzlFieldProto >&
      indices() const;

  // repeated .sawzall.SzlFieldProto Fields = 5;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 5;
  const ::sawzall::SzlFieldProto& fields(int index) const;
  ::sawzall::SzlFieldProto* mutable_fields(int index);
  ::sawzall::SzlFieldProto* add_fields();
  ::google::protobuf::RepeatedPtrField< ::sawzall::SzlFieldProto >*
      mutable_fields();
  const ::google::protobuf::RepeatedPtrField< ::sawzall::SzlFieldProto >&
      fields() const;

  // optional string Table = 2;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 2;
  const ::std::string& table() const;
  void set_table(const ::std::string& value);
  #if LANG_CXX11
  void set_table(::std::string&& value);
  #endif
  void set_table(const char* value);
  void set_table(const char* value, size_t size);
  ::std::string* mutable_table();
  ::std::string* release_table();
  void set_allocated_table(::std::string* table);

  // optional .sawzall.SzlFieldProto Element = 6;
  bool has_element() const;
  void clear_element();
  static const int kElementFieldNumber = 6;
  const ::sawzall::SzlFieldProto& element() const;
  ::sawzall::SzlFieldProto* mutable_element();
  ::sawzall::SzlFieldProto* release_element();
  void set_allocated_element(::sawzall::SzlFieldProto* element);

  // optional .sawzall.SzlFieldProto Weight = 7;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 7;
  const ::sawzall::SzlFieldProto& weight() const;
  ::sawzall::SzlFieldProto* mutable_weight();
  ::sawzall::SzlFieldProto* release_weight();
  void set_allocated_weight(::sawzall::SzlFieldProto* weight);

  // required int32 Kind = 1;
  bool has_kind() const;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::google::protobuf::int32 kind() const;
  void set_kind(::google::protobuf::int32 value);

  // optional int32 Param = 3;
  bool has_param() const;
  void clear_param();
  static const int kParamFieldNumber = 3;
  ::google::protobuf::int32 param() const;
  void set_param(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sawzall.SzlTypeProto)
 private:
  void set_has_kind();
  void clear_has_kind();
  void set_has_table();
  void clear_has_table();
  void set_has_param();
  void clear_has_param();
  void set_has_element();
  void clear_has_element();
  void set_has_weight();
  void clear_has_weight();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sawzall::SzlFieldProto > indices_;
  ::google::protobuf::RepeatedPtrField< ::sawzall::SzlFieldProto > fields_;
  ::google::protobuf::internal::ArenaStringPtr table_;
  ::sawzall::SzlFieldProto* element_;
  ::sawzall::SzlFieldProto* weight_;
  ::google::protobuf::int32 kind_;
  ::google::protobuf::int32 param_;
  friend struct protobuf_emitvalues_2fsawzall_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SzlFieldProto

// required string Label = 1;
inline bool SzlFieldProto::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SzlFieldProto::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SzlFieldProto::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SzlFieldProto::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& SzlFieldProto::label() const {
  // @@protoc_insertion_point(field_get:sawzall.SzlFieldProto.Label)
  return label_.GetNoArena();
}
inline void SzlFieldProto::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sawzall.SzlFieldProto.Label)
}
#if LANG_CXX11
inline void SzlFieldProto::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sawzall.SzlFieldProto.Label)
}
#endif
inline void SzlFieldProto::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sawzall.SzlFieldProto.Label)
}
inline void SzlFieldProto::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sawzall.SzlFieldProto.Label)
}
inline ::std::string* SzlFieldProto::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:sawzall.SzlFieldProto.Label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SzlFieldProto::release_label() {
  // @@protoc_insertion_point(field_release:sawzall.SzlFieldProto.Label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SzlFieldProto::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:sawzall.SzlFieldProto.Label)
}

// required string Type = 2;
inline bool SzlFieldProto::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SzlFieldProto::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SzlFieldProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SzlFieldProto::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& SzlFieldProto::type() const {
  // @@protoc_insertion_point(field_get:sawzall.SzlFieldProto.Type)
  return type_.GetNoArena();
}
inline void SzlFieldProto::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sawzall.SzlFieldProto.Type)
}
#if LANG_CXX11
inline void SzlFieldProto::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sawzall.SzlFieldProto.Type)
}
#endif
inline void SzlFieldProto::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sawzall.SzlFieldProto.Type)
}
inline void SzlFieldProto::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sawzall.SzlFieldProto.Type)
}
inline ::std::string* SzlFieldProto::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:sawzall.SzlFieldProto.Type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SzlFieldProto::release_type() {
  // @@protoc_insertion_point(field_release:sawzall.SzlFieldProto.Type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SzlFieldProto::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:sawzall.SzlFieldProto.Type)
}

// optional int32 Tag = 3;
inline bool SzlFieldProto::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SzlFieldProto::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SzlFieldProto::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SzlFieldProto::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 SzlFieldProto::tag() const {
  // @@protoc_insertion_point(field_get:sawzall.SzlFieldProto.Tag)
  return tag_;
}
inline void SzlFieldProto::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:sawzall.SzlFieldProto.Tag)
}

// -------------------------------------------------------------------

// SzlTypeProto

// required int32 Kind = 1;
inline bool SzlTypeProto::has_kind() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SzlTypeProto::set_has_kind() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SzlTypeProto::clear_has_kind() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SzlTypeProto::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::google::protobuf::int32 SzlTypeProto::kind() const {
  // @@protoc_insertion_point(field_get:sawzall.SzlTypeProto.Kind)
  return kind_;
}
inline void SzlTypeProto::set_kind(::google::protobuf::int32 value) {
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:sawzall.SzlTypeProto.Kind)
}

// optional string Table = 2;
inline bool SzlTypeProto::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SzlTypeProto::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SzlTypeProto::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SzlTypeProto::clear_table() {
  table_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_table();
}
inline const ::std::string& SzlTypeProto::table() const {
  // @@protoc_insertion_point(field_get:sawzall.SzlTypeProto.Table)
  return table_.GetNoArena();
}
inline void SzlTypeProto::set_table(const ::std::string& value) {
  set_has_table();
  table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sawzall.SzlTypeProto.Table)
}
#if LANG_CXX11
inline void SzlTypeProto::set_table(::std::string&& value) {
  set_has_table();
  table_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sawzall.SzlTypeProto.Table)
}
#endif
inline void SzlTypeProto::set_table(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_table();
  table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sawzall.SzlTypeProto.Table)
}
inline void SzlTypeProto::set_table(const char* value, size_t size) {
  set_has_table();
  table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sawzall.SzlTypeProto.Table)
}
inline ::std::string* SzlTypeProto::mutable_table() {
  set_has_table();
  // @@protoc_insertion_point(field_mutable:sawzall.SzlTypeProto.Table)
  return table_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SzlTypeProto::release_table() {
  // @@protoc_insertion_point(field_release:sawzall.SzlTypeProto.Table)
  clear_has_table();
  return table_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SzlTypeProto::set_allocated_table(::std::string* table) {
  if (table != NULL) {
    set_has_table();
  } else {
    clear_has_table();
  }
  table_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table);
  // @@protoc_insertion_point(field_set_allocated:sawzall.SzlTypeProto.Table)
}

// optional int32 Param = 3;
inline bool SzlTypeProto::has_param() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SzlTypeProto::set_has_param() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SzlTypeProto::clear_has_param() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SzlTypeProto::clear_param() {
  param_ = 0;
  clear_has_param();
}
inline ::google::protobuf::int32 SzlTypeProto::param() const {
  // @@protoc_insertion_point(field_get:sawzall.SzlTypeProto.Param)
  return param_;
}
inline void SzlTypeProto::set_param(::google::protobuf::int32 value) {
  set_has_param();
  param_ = value;
  // @@protoc_insertion_point(field_set:sawzall.SzlTypeProto.Param)
}

// repeated .sawzall.SzlFieldProto Indices = 4;
inline int SzlTypeProto::indices_size() const {
  return indices_.size();
}
inline void SzlTypeProto::clear_indices() {
  indices_.Clear();
}
inline const ::sawzall::SzlFieldProto& SzlTypeProto::indices(int index) const {
  // @@protoc_insertion_point(field_get:sawzall.SzlTypeProto.Indices)
  return indices_.Get(index);
}
inline ::sawzall::SzlFieldProto* SzlTypeProto::mutable_indices(int index) {
  // @@protoc_insertion_point(field_mutable:sawzall.SzlTypeProto.Indices)
  return indices_.Mutable(index);
}
inline ::sawzall::SzlFieldProto* SzlTypeProto::add_indices() {
  // @@protoc_insertion_point(field_add:sawzall.SzlTypeProto.Indices)
  return indices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::sawzall::SzlFieldProto >*
SzlTypeProto::mutable_indices() {
  // @@protoc_insertion_point(field_mutable_list:sawzall.SzlTypeProto.Indices)
  return &indices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::sawzall::SzlFieldProto >&
SzlTypeProto::indices() const {
  // @@protoc_insertion_point(field_list:sawzall.SzlTypeProto.Indices)
  return indices_;
}

// repeated .sawzall.SzlFieldProto Fields = 5;
inline int SzlTypeProto::fields_size() const {
  return fields_.size();
}
inline void SzlTypeProto::clear_fields() {
  fields_.Clear();
}
inline const ::sawzall::SzlFieldProto& SzlTypeProto::fields(int index) const {
  // @@protoc_insertion_point(field_get:sawzall.SzlTypeProto.Fields)
  return fields_.Get(index);
}
inline ::sawzall::SzlFieldProto* SzlTypeProto::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:sawzall.SzlTypeProto.Fields)
  return fields_.Mutable(index);
}
inline ::sawzall::SzlFieldProto* SzlTypeProto::add_fields() {
  // @@protoc_insertion_point(field_add:sawzall.SzlTypeProto.Fields)
  return fields_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::sawzall::SzlFieldProto >*
SzlTypeProto::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:sawzall.SzlTypeProto.Fields)
  return &fields_;
}
inline const ::google::protobuf::RepeatedPtrField< ::sawzall::SzlFieldProto >&
SzlTypeProto::fields() const {
  // @@protoc_insertion_point(field_list:sawzall.SzlTypeProto.Fields)
  return fields_;
}

// optional .sawzall.SzlFieldProto Element = 6;
inline bool SzlTypeProto::has_element() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SzlTypeProto::set_has_element() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SzlTypeProto::clear_has_element() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SzlTypeProto::clear_element() {
  if (element_ != NULL) element_->::sawzall::SzlFieldProto::Clear();
  clear_has_element();
}
inline const ::sawzall::SzlFieldProto& SzlTypeProto::element() const {
  const ::sawzall::SzlFieldProto* p = element_;
  // @@protoc_insertion_point(field_get:sawzall.SzlTypeProto.Element)
  return p != NULL ? *p : *reinterpret_cast<const ::sawzall::SzlFieldProto*>(
      &::sawzall::_SzlFieldProto_default_instance_);
}
inline ::sawzall::SzlFieldProto* SzlTypeProto::mutable_element() {
  set_has_element();
  if (element_ == NULL) {
    element_ = new ::sawzall::SzlFieldProto;
  }
  // @@protoc_insertion_point(field_mutable:sawzall.SzlTypeProto.Element)
  return element_;
}
inline ::sawzall::SzlFieldProto* SzlTypeProto::release_element() {
  // @@protoc_insertion_point(field_release:sawzall.SzlTypeProto.Element)
  clear_has_element();
  ::sawzall::SzlFieldProto* temp = element_;
  element_ = NULL;
  return temp;
}
inline void SzlTypeProto::set_allocated_element(::sawzall::SzlFieldProto* element) {
  delete element_;
  element_ = element;
  if (element) {
    set_has_element();
  } else {
    clear_has_element();
  }
  // @@protoc_insertion_point(field_set_allocated:sawzall.SzlTypeProto.Element)
}

// optional .sawzall.SzlFieldProto Weight = 7;
inline bool SzlTypeProto::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SzlTypeProto::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SzlTypeProto::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SzlTypeProto::clear_weight() {
  if (weight_ != NULL) weight_->::sawzall::SzlFieldProto::Clear();
  clear_has_weight();
}
inline const ::sawzall::SzlFieldProto& SzlTypeProto::weight() const {
  const ::sawzall::SzlFieldProto* p = weight_;
  // @@protoc_insertion_point(field_get:sawzall.SzlTypeProto.Weight)
  return p != NULL ? *p : *reinterpret_cast<const ::sawzall::SzlFieldProto*>(
      &::sawzall::_SzlFieldProto_default_instance_);
}
inline ::sawzall::SzlFieldProto* SzlTypeProto::mutable_weight() {
  set_has_weight();
  if (weight_ == NULL) {
    weight_ = new ::sawzall::SzlFieldProto;
  }
  // @@protoc_insertion_point(field_mutable:sawzall.SzlTypeProto.Weight)
  return weight_;
}
inline ::sawzall::SzlFieldProto* SzlTypeProto::release_weight() {
  // @@protoc_insertion_point(field_release:sawzall.SzlTypeProto.Weight)
  clear_has_weight();
  ::sawzall::SzlFieldProto* temp = weight_;
  weight_ = NULL;
  return temp;
}
inline void SzlTypeProto::set_allocated_weight(::sawzall::SzlFieldProto* weight) {
  delete weight_;
  weight_ = weight;
  if (weight) {
    set_has_weight();
  } else {
    clear_has_weight();
  }
  // @@protoc_insertion_point(field_set_allocated:sawzall.SzlTypeProto.Weight)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace sawzall

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sawzall::SzlTypeProto_KIND> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sawzall::SzlTypeProto_KIND>() {
  return ::sawzall::SzlTypeProto_KIND_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_emitvalues_2fsawzall_2eproto__INCLUDED
